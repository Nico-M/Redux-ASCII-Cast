一个应用往往会有一些需要维护的状态，比如数据状态， UI 元素的状态，随着应用规模的变大，状态变得越来越复杂，管理这些不断在变化的状态让人越来越头疼。

举个例子，在一个照片墙应用中，你点击了一个底部的蓝色“加载更多”按钮，这个按钮变成灰色了，页面上面显示了一个”加载中“图标，过了一会，”加载中“图标消失，“加载更多”按钮变回蓝色，页面上面显示一些美丽的图片。这里面涉及的状态：
- “加载更多”按钮的 UI 状态
- “加载中”图标的 UI 状态
- 向服务器请求图片返回的图片 url 的数据状态
- 图片的容器的 UI 状态

想想看，如果把这些状态的变化串联在一起处理，当”加载中“图标消失了但没有图片显示，你不仅要检查是否包含图片的容器的 UI 状态变化出错了，还要去检查图片数据是否真的拿到了。因为它们在两个不同的地方独立存在着。

如果设定只有图片数据的变化能够更新图片容器，”加载中“图标以及”加载更多“按钮的 UI 状态，这样我们就限制了单独状态的变化，让整体状态的变化变得可预测。

Redux 致力于使状态的转变变得可预测， 这需要实施一些限制，去确定状态怎样和何时去更新。

这些限制都反映在 Redux 的三大原则中。

在这节课中，要介绍的是 Redux 中三大原则第一条：无论你的 (web) 应用有多么复杂，所有的改变，包括数据， UI 元素状态的改变都包含在惟一的一个对象 (`Object`) 里面，我们称它为状态 (`state`) /状态树 (`state tree`)。

这样我们能够能容易地管理全局的状态。

我们将列举一些可操作的例子帮助你了解这一原则，但是你现在无需马上投入到代码里面，因为在接下来的课程里我们会慢慢解析这里面发生了什么。

你可以观测这个简单的[计数器](https://jsbin.com/siragey/edit?console,output)，去体会什么是状态变化。

然后在[多个独立计数器](https://jsbin.com/zazatug/edit?console,output)，观测有多个可变状态的情况。

在更复杂一些的例子里，会有更多的状态需要去维护，比如这个简单的[代办事项 App](https://jsbin.com/jeqeyup/edit?console,output)，你可以添加代办事项，能标记它们为完成，还可以改变过滤条件。你会留意到所有的变化都被储存在一个大的对象 (`Object`)里面。

所以，无论你的应用的状态有多复杂，你都可以把它们存放在一个对象 (`Object`)里面去管理。而在 Redux 里面，你必须这么做。
