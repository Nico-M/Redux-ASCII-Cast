在这节课里，我们将介绍 Redux 的第二个原则：状态是只读的，唯一能改变状态的方法是分发 (`dispatch`) 一个动作 (`action`) （一个普通对象 (`Object`) 用于描述发生了什么改变）。

这样的规定是为了更好地管理状态转换发生的顺序，不直接修改状态而是表达出改变状态的意图，让所有的改变都中心化，按一定顺序执行，有效避免同时修改状态的竞争情况发生，减少错误出现的可能性，同时让状态的转换变得更可预测。

动作 (`action`) 只是普通的 JavaScript `对象`，它们能被打印 (`console.log`), 还能被储存用于之后的重现和调试。

动作 (`action`) 的内部结构是没有严格限制的，唯一的约束是必须要有类型 (`type`) 属性, 并且 `类型` 属性不能为 `undefined`，一般推荐使用字符串类型，因为便于储存和比较，具有描述性。

通过定义不同`类型`的动作 (`action`)去描述不同状态变化，不同的应用会用到不同的`类型`.

比如观测这个最简单的[计数器](https://jsbin.com/tutoxim/edit?console,output), 我们只需要两种`类型` (`INCREMENT` 和 `DECREMENT`）的动作 (`action`) ，并且你会发现它没有提供其他额外的信息，因为仅仅用`类型`已经足够描述这个应用的状态变化了。

但是到了[多个独立计数器](https://jsbin.com/topexiy/edit?console,output)，我们不仅添加了 `ADD_COUNTER` 和 `REMOVE_COUNTER` `类型` 的动作 (`action`) ，还为 `INCREMENT` 和 `DECREMENT` 动作 (`action`)添加了额外的信息: 索引 (`index`) 属性，用于准确描述哪个计数器发生了变化。

这样的做法可以很容易扩展到中大型的应用中，比如[代办事项 App](https://jsbin.com/gitehe/edit?console,output)中，你可以观察每一个操作对应触发的动作 (`action`) ，对应的元素实际上并不需要知道动作如何完成状态如何转变，只需要分发 (`dispatch`) 一个动作 (`action`) ，传入必要的信息就足够了。

记住，无论是网络请求还是用户交互，任何数据想进入 Redux 应用 (状态树 (`state tree`)) 内部都只能通过分发动作来完成。
